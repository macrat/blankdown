<!DOCTYPE html>

<html>
	<head>
		<title>blankdown - yet yet yet another markdown editor</title>

		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/routeros.min.css">

		<script src="https://unpkg.com/vue/dist/vue.min.js"></script>
		<script src="https://unpkg.com/marked/marked.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

		<style>
			body {
				margin: 0;
				height: 100vh;
			}
			.nav-content-area {
				height: 100vh;
				overflow: auto;
				display: flex;
				flex-direction: column;
			}
			nav {
				flex: 0 0 auto;
			}
		</style>

		<style>
			.nav-header {
				background-color: #666;
				padding: .3em .5em;
			}

			.nav-header-link {
				color: white;
				text-decoration: none;
				margin: 0 .5em;
				user-select: none;
			}

			.nav-drawer {
				background-color: rgba(255, 255, 255, 0.8);
				padding: 0 .5em;
				position: absolute;
				top: 0;
				bottom: 0;
				left: 0;
				width: 15em;
				z-index: 2;
			}

			.nav-drawer hr {
				background-color: #666;
				border: none;
				height: 1px;
			}
			
			.nav-drawer-title {
				font-size: 150%;
				margin: .5em 0;
				border-bottom: 1px solid #666;
				user-select: none;
			}

			.nav-drawer-link {
				color: black;
				text-decoration: none;
				display: block;
				margin: .7em 0;
			}

			.nav-blind {
				position: fixed;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;
			}

			.nav-slide-enter-active, .nav-slide-leave-active {
				transition: left .3s, opacity .3s;
			}
			.nav-slide-enter, .nav-slide-leave-to {
				left: -15em;
				opacity: 0.5;
			}

			.nav-show-content {
				transition: filter .3s;
				filter: none;
			}
			.nav-hide-content {
				transition: filter .3s;
				filter: blur(5px) grayscale(80%);
			}
		</style>
	</head>

	<body>
		<div id=app></div>
	</body>

	<script>
marked.setOptions({
	highlight(code, lang) {
		try {
			if (lang) {
				return hljs.highlight(lang, code, true).value;
			} else {
				return hljs.highlightAuto(code).value;
			}
		} catch(e) {
			return code;
		}
	},
});


function process_markdown(markdown) {
	return marked(markdown, {
		sanitize: true,
	});
}


Vue.directive('focus', {
	inserted(el) {
		el.focus();
	},
});


Vue.component('nav-wrapper', {
	computed: {
		groups() {
			this.$slots.default.forEach(slot => {
				console.log(slot.componentOptions, slot);
			});

			return this.$slots.default.filter(slot => slot.componentOptions).map(slot => {
				return {
					slot: slot,
					name: slot.componentOptions.propsData.name,
				};
			});
		},
	},
	data() {
		return {
			opened: false,
		};
	},
	template: `
		<div class="nav-wrapper">
			<div class="nav-content-area" :class="{ 'nav-show-content': !opened, 'nav-hide-content': opened }">
				<nav class="nav-header">
					<a href class="nav-header-link" v-for="group in groups" @click.prevent="open(group.slot.componentInstance)">{{ group.name }}</a>
				</nav>
				<div class="nav-blind" v-if=opened @click=closeAll></div>
				<slot name=content />
			</div>
			<div>
				<slot />
			</div>
		</div>
	`,
	mounted() {
		this.groups.forEach(x => x.slot.componentInstance.$on('opened', opened => {
			this.opened = opened;
			this.$emit('opened', opened);
		}));
	},
	methods: {
		closeAll() {
			this.groups.forEach(slot => {
				slot.slot.componentInstance.close();
			});
		},
		open(component) {
			this.closeAll();
			component.open();
		},
	},
});


Vue.component('nav-drawer', {
	props: ['name'],
	data() {
		return {
			opened: false,
		};
	},
	template: `
		<transition name=nav-slide>
			<div class="nav-drawer" v-if=opened>
				<h1 class="nav-drawer-title" @click=close>{{ name }}</h1>
				<slot />
			</div>
		</transition>
	`,
	methods: {
		open() {
			this.opened = true;
			this.$emit('opened', true);
		},
		close() {
			this.opened = false;
			this.$emit('opened', false);
		},
	},
});


Vue.component('nav-button', {
	template: '<a href @click.prevent=click class="nav-drawer-link"><slot /></a>',
	methods: {
		click() {
			this.$emit('click');
			this.$parent.close();
		},
	},
});


Vue.component('synchronize-scroll', {
	template: `<div><slot /></div>`,
	computed: {
		elements() {
			return this.$slots.default.filter(x => x.componentInstance).map(x => x.componentInstance.$el);
		},
	},
	mounted() {
		this.elements.forEach(elm => {
			elm.addEventListener('scroll', () => {
				Vue.nextTick(() => {
					const rate = Math.round(elm.scrollTop / (elm.scrollHeight - elm.clientHeight) * 1000) / 1000;
					this.elements.forEach(e => {
						if (e != elm) {
							e.scrollTo(0, (e.scrollHeight - e.clientHeight) * rate);
						}
					});
				});
			});
		});
	},
});


Vue.component('markdown-writer', {
	props: ['value'],
	data() {
		return {
			markdown: this.value,
			childStyle: {
				'flex': '1 1 0',
			},
		};
	},
	created() {
		this.$watch('value', function() {
			this.markdown = this.value;
		});
	},
	template: `
		<synchronize-scroll style="display: flex;">
			<markdown-editor
				:style=childStyle
				style="outline: none; border: 0; resize: none;"
				v-model=markdown
				@input=update
				v-focus>
			</markdown-editor>

			<markdown-viewer
				:style=childStyle
				style="padding-left: 1em; border-left: 1px solid gray;"
				:value=markdown>
			</markdown-viewer>
		</synchronize-scroll>
	`,
	methods: {
		update(value) {
			this.$emit('input', value);
		},
	},
});


Vue.component('markdown-editor', {
	props: ['value'],
	template: `
		<textarea
			style="box-sizing: border-box;"
			@keydown.tab.prevent=indent
			@input="update($event.target.value)"
			:value=value></textarea>
	`,
	methods: {
		indent() {
			const elm = this.$el;
			const start = elm.selectionStart;
			const diff = start != elm.selectionEnd;

			elm.value = this.value.slice(0, elm.selectionStart) + '    ' + this.value.slice(elm.selectionEnd);
			elm.selectionStart = elm.selectionEnd = start + 4;

			this.update(elm.value);
		},
		update(value) {
			this.$emit('input', value);
		},
	},
});


Vue.component('markdown-viewer', {
	props: ['value'],
	template: '<div v-html=html style="box-sizing: border-box; overflow: auto;"></div>',
	computed: {
		html() {
			return process_markdown(this.value);
		},
	},
});


const vm = new Vue({
	el: '#app',
	template: `
		<main>
			<nav-wrapper>
				<nav-drawer name="FILE">
					<nav-button @click=saveFile>save</nav-button>
					<nav-button @click=exportFile>export</nav-button>
					<nav-button @click=selectFile>load</nav-button>
					<hr>
					<nav-button>recent file</nav-button>
					<nav-button>recent file</nav-button>
					<nav-button>recent file</nav-button>
					<nav-button>recent file</nav-button>
					<nav-button>recent file</nav-button>
				</nav-drawer>

				<nav-drawer name="EDIT">
					<nav-button>insert header</nav-button>
					<nav-button>insert table</nav-button>
				</nav-drawer>

				<nav-drawer name="HELP">
					<nav-button>about</nav-button>
				</nav-drawer>

				<markdown-writer slot="content" style="flex: 1 1 0" v-model="markdown"></markdown-writer>
			</nav-wrapper>

			<div style="display: none;">
				<input id=input-file @change="loadFile(this.event.target.files)" type=file accept="text/*">
				<a id=download-link :href=downloadURL :download=downloadName></a>
			</div>
		</main>
	`,
	data: {
		markdown: "# hello world\nwelcome to **blankdown**!\n\n```\nprint('this is ', end='')\n\nwhile True:\n    print('yet ', end='')\n\nprint('another markdown editor')\n```\n",
		downloadURL: '',
		downloadName: '',
	},
	methods: {
		startDownload(filename, mimetype, data) {
			this.downloadURL = URL.createObjectURL(new Blob([ data ], { type: mimetype }));
			this.downloadName = filename;
			Vue.nextTick(() => {
				this.$el.querySelector('#download-link').click();
			});
		},
		saveFile() {
			this.startDownload('markdown.md', this.markdown, 'text/markdown');
		},
		exportFile() {
			this.startDownload(
				'markdown.html',
				'text/html',
				process_markdown(this.markdown),
			);
		},
		selectFile() {
			this.$el.querySelector('#input-file').click();
		},
		loadFile(files) {
			if (!files) {
				return;
			}

			const reader = new FileReader();
			reader.addEventListener('load', () => {
				this.markdown = reader.result;
			});
			reader.readAsText(files[0]);
		},
	},
});
	</script>
</html>
